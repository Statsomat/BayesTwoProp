filename = filename,
decimal = decimal,
data = data,
outcome = outcome,
exposure = exposure,
level = level
))
# Import libraries
library(rmarkdown)
library(data.table)
library(shiny)
##############################################################
# Simulate the Shiny GUI
# The user uploads a file or inserts the cell frequencies directly
# If both file and cell frequencies are nonempty, then the algorithms considers the file
# Otherwise, the cell frequencies must be nonempty
##############################################################
# Data as a file
filename <- "datasets/testfile.csv"
decimal <- "."
#data <- fread(filename, header = "auto", sep ="auto", dec = decimal, encoding ="UTF-8", data.table = FALSE, na.strings = "")
outcome <- "y" # outcome variable
exposure <- "s" # exposure variable
level <- 1 # level for the existence of the outcome
# Data as cell frequencies
s1 <- 21 # outcome positive, set to NA if you want to consider the file from above
n1 <- 938812 # exposed
s2 <- 6 # outcome positive
n2 <- 938812 # not-exposed
# User delivers the priors (are beta distributions with parameters a and b, for each Theta)
a1 <- 1/2
b1 <- 1/2
a2 <- 1/2
b2 <- 1/2
# User selection for the function of parameters
## Possible values: "Theta1-Theta2", "Theta1/Theta2", "1-Theta1/Theta2"
## Use integers to represent values from above
user_selection_function_param <- 2
# Region of practical equivalence (we will learn later about it)
rope_user <- NULL
##############################################################
# Run parametric, automatic .Rmd file
##############################################################
rmarkdown::render("report.Rmd", params = list(
filename = filename,
decimal = decimal,
data = data,
outcome = outcome,
exposure = exposure,
level = level
))
# Import libraries
library(rmarkdown)
library(data.table)
library(shiny)
##############################################################
# Simulate the Shiny GUI
# The user uploads a file or inserts the cell frequencies directly
# If both file and cell frequencies are nonempty, then the algorithms considers the file
# Otherwise, the cell frequencies must be nonempty
##############################################################
# Data as a file
filename <- "datasets/testfile.csv"
decimal <- "."
data <- fread(filename, header = "auto", sep ="auto", dec = decimal, encoding ="UTF-8", data.table = FALSE, na.strings = "")
outcome <- "y" # outcome variable
exposure <- "s" # exposure variable
level <- 1 # level for the existence of the outcome
# Data as cell frequencies
s1 <- 21 # outcome positive, set to NA if you want to consider the file from above
n1 <- 938812 # exposed
s2 <- 6 # outcome positive
n2 <- 938812 # not-exposed
# User delivers the priors (are beta distributions with parameters a and b, for each Theta)
a1 <- 1/2
b1 <- 1/2
a2 <- 1/2
b2 <- 1/2
# User selection for the function of parameters
## Possible values: "Theta1-Theta2", "Theta1/Theta2", "1-Theta1/Theta2"
## Use integers to represent values from above
user_selection_function_param <- 2
# Region of practical equivalence (we will learn later about it)
rope_user <- NULL
##############################################################
# Run parametric, automatic .Rmd file
##############################################################
rmarkdown::render("report.Rmd", params = list(
filename = filename,
decimal = decimal,
data = data,
outcome = outcome,
exposure = exposure,
level = level
))
##############################################################
# Run parametric, automatic .Rmd file
##############################################################
rmarkdown::render("report.Rmd", params = list(
filename = filename,
decimal = decimal,
data = data,
outcome = outcome,
exposure = exposure,
level = level,
s1=s1,
n1=n1,
s2=s2,
n2=n2,
a1=a1,
b1=b1,
a2=a2,
b2=b2
))
shiny::runApp()
install.packages("excelR")
library(excelR)
columns = data.frame(title=c('Sepal Length', 'Sepal Width', 'Petal Length','Petal Width', 'Species'),
width= c(200, 200, 200, 200, 200))
nestedHeaders = list( data.frame(title=c("Plant Attribute"), colspan=c(5)),
data.frame(title=c("Sepal Attributes", "Petal Attributes", "Species"),
colspan=c(2, 2, 1)))
excelTable(data=head(iris), columns = columns, nestedHeaders = nestedHeaders)
library(shiny)
library(excelR)
shinyApp(
ui = fluidPage(excelOutput("table")),
server = function(input, output, session) {
output$table <-
renderExcel(excelTable(data = head(iris)))
}
)
library(shiny)
library(excelR)
shinyApp(
ui = fluidPage(excelOutput("table")),
server = function(input, output, session) {
output$table <-
renderExcel(excelTable(data = head(iris)))
observeEvent(input$table,{
table_data <- excel_to_R(input$table)
if(!is.null(table_data)){
print(table_data)
}
})
}
)
runApp()
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(DT)
library(tidyverse)
ui <- fluidPage(
# Application title
titlePanel("Editable Dataframe and Plot"),
# Sidebar
sidebarLayout(
sidebarPanel(
DTOutput("my_datatable"),
actionButton("go",label = "Plot Data")
),
# Show plot
mainPanel(
plotOutput("my_plot")
)
)
)
server <- function(input, output) {
#initialize a blank dataframe
v <- reactiveValues(data = {
data.frame(x = numeric(0),y = numeric(0)) %>%
add_row(x = rep(0,10),y = rep(0,10))
})
#output the datatable based on the dataframe (and make it editable)
output$my_datatable <- renderDT({
DT::datatable(v$data, editable = TRUE)
})
#when there is any edit to a cell, write that edit to the initial dataframe
#check to make sure it's positive, if not convert
observeEvent(input$my_datatable_cell_edit, {
#get values
info = input$my_datatable_cell_edit
i = as.numeric(info$row)
j = as.numeric(info$col)
k = as.numeric(info$value)
if(k < 0){ #convert to positive if negative
k <- k * -1
}
#write values to reactive
v$data[i,j] <- k
})
#render plot
output$my_plot <- renderPlot({
req(input$go) #require the input button to be non-0 (ie: don't load the plot when the app first loads)
isolate(v$data) %>%  #don't react to any changes in the data
ggplot(aes(x,y)) +
geom_point() +
geom_smooth(method = "lm")
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(DT)
library(tidyverse)
ui <- fluidPage(
# Application title
titlePanel("Editable Dataframe and Plot"),
# Sidebar
sidebarLayout(
sidebarPanel(
DTOutput("my_datatable"),
actionButton("go",label = "Plot Data")
),
# Show plot
mainPanel(
plotOutput("my_plot")
)
)
)
server <- function(input, output) {
#initialize a blank dataframe
v <- reactiveValues(data = {
data.frame(x = numeric(0),y = numeric(0)) %>%
add_row(x = rep(0,10),y = rep(0,10))
})
#output the datatable based on the dataframe (and make it editable)
output$my_datatable <- renderDT({
DT::datatable(v$data, editable = TRUE)
})
#when there is any edit to a cell, write that edit to the initial dataframe
#check to make sure it's positive, if not convert
observeEvent(input$my_datatable_cell_edit, {
#get values
info = input$my_datatable_cell_edit
i = as.numeric(info$row)
j = as.numeric(info$col)
k = as.numeric(info$value)
if(k < 0){ #convert to positive if negative
k <- k * -1
}
#write values to reactive
v$data[i,j] <- k
})
#render plot
output$my_plot <- renderPlot({
req(input$go) #require the input button to be non-0 (ie: don't load the plot when the app first loads)
isolate(v$data) %>%  #don't react to any changes in the data
ggplot(aes(x,y)) +
geom_point() +
geom_smooth(method = "lm")
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp()
runApp()
runApp()
runApp()
runApp()
library(shiny)
library(DT)
library(tidyverse)
ui <- fluidPage(
# Application title
titlePanel("Editable Dataframe and Plot"),
# Sidebar
sidebarLayout(
sidebarPanel(
DTOutput("my_datatable"),
actionButton("go",label = "Plot Data")
),
# Show plot
mainPanel(
plotOutput("my_plot")
)
)
)
server <- function(input, output) {
#initialize a blank dataframe
v <- reactiveValues(data = {
data.frame(x = numeric(0),y = numeric(0)) %>%
add_row(x = rep(0,10),y = rep(0,10))
})
#output the datatable based on the dataframe (and make it editable)
output$my_datatable <- renderDT({
DT::datatable(v$data, editable = TRUE)
})
#when there is any edit to a cell, write that edit to the initial dataframe
#check to make sure it's positive, if not convert
observeEvent(input$my_datatable_cell_edit, {
#get values
info = input$my_datatable_cell_edit
i = as.numeric(info$row)
j = as.numeric(info$col)
k = as.numeric(info$value)
if(k < 0){ #convert to positive if negative
k <- k * -1
}
#write values to reactive
v$data[i,j] <- k
})
#render plot
output$my_plot <- renderPlot({
req(input$go) #require the input button to be non-0 (ie: don't load the plot when the app first loads)
isolate(v$data) %>%  #don't react to any changes in the data
ggplot(aes(x,y)) +
geom_point() +
geom_smooth(method = "lm")
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
library(excelR)
shinyApp(
ui = fluidPage(excelOutput("table")),
server = function(input, output, session) {
output$table <-
renderExcel(excelTable(data = head(iris)))
observeEvent(input$table,{
table_data <- excel_to_R(input$table)
if(!is.null(table_data)){
print(table_data)
}
})
}
)
runApp()
if(interactive()){
library(shiny)
library(excelR)
shinyApp(
ui = fluidPage(excelOutput("table")),
server = function(input, output, session) {
output$table <-
renderExcel(excelTable(data = head(iris)))
observeEvent(input$table,{
print(excel_to_R(input$table))
})
}
)
}
runApp()
runApp()
library(shiny)
ui <- fluidPage(
fluidRow(
tags$head(
tags$style(type="text/css","label{ display: table-cell; text-align: center;vertical-align: middle; } .form-group { display: table-row;}")
),
column(5,style='background-color:#f2f2f2;min-width: 300px;',
h4("Label Issue"),
br(),
tags$table(
tags$tr(width = "100%",
tags$td(width = "60%", div(style = "font-size:10px;", "This is label1. I want all labels on left")),
tags$td(width = "40%", textInput(inputId = "a", label = NULL))),
tags$tr(width = "100%",
tags$td(width = "60%", tags$div(style = "font-size:10pX;", "label2")),
tags$td(width = "40%", textInput(inputId = "b", label = NULL)))
)
)
)
)
server <- function(input, output,session) {
}
shinyApp(ui, server)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
library("shiny")
library("shinyMatrix")
m <- matrix(runif(12), 6, 2, dimnames = list(NULL, c("x", "y")))
ui <- fluidPage(
titlePanel("shinyMatrix: Simple App"),
sidebarPanel(
width = 6,
tags$h4("Data"),
matrixInput(
"sample",
value = m,
rows = list(
extend = TRUE
),
cols = list(
names = TRUE
)
)
),
mainPanel(
width = 6,
plotOutput("scatter")
)
)
server <- function(input, output, session) {
output$scatter <- renderPlot({
plot(input$sample, col = "red", main = "Scatterplot")
})
}
shinyApp(ui, server)
library("shiny")
library("shinyMatrix")
m <- matrix(runif(12), 6, 2, dimnames = list(NULL, c("x", "y")))
ui <- fluidPage(
titlePanel("shinyMatrix: Simple App"),
sidebarPanel(
width = 6,
tags$h4("Data"),
matrixInput(
"sample",
value = m,
rows = list(
extend = TRUE
),
cols = list(
names = TRUE
)
)
),
mainPanel(
width = 6,
plotOutput("scatter")
)
)
server <- function(input, output, session) {
output$scatter <- renderPlot({
plot(input$sample, col = "red", main = "Scatterplot")
})
}
shinyApp(ui, server)
library("shiny")
library("shinyMatrix")
m <- matrix(runif(12), 6, 2, dimnames = list(NULL, c("x", "y")))
ui <- fluidPage(
titlePanel("shinyMatrix: Simple App"),
sidebarPanel(
width = 6,
tags$h4("Data"),
matrixInput(
"sample",
value = m,
rows = list(
extend = TRUE
),
cols = list(
names = TRUE
)
)
),
mainPanel(
width = 6,
plotOutput("scatter")
)
)
server <- function(input, output, session) {
K <- input$sample
output$scatter <- renderPlot({
plot(input$sample, col = "red", main = "Scatterplot")
})
}
shinyApp(ui, server)
library("shiny")
library("shinyMatrix")
m <- matrix(runif(12), 6, 2, dimnames = list(NULL, c("x", "y")))
ui <- fluidPage(
titlePanel("shinyMatrix: Simple App"),
sidebarPanel(
width = 6,
tags$h4("Data"),
matrixInput(
"sample",
value = m,
rows = list(
extend = TRUE
),
cols = list(
names = TRUE
)
)
),
mainPanel(
width = 6,
plotOutput("scatter")
)
)
server <- function(input, output, session) {
K <- input$sample
output$scatter <- renderPlot({
plot(input$sample, col = "red", main = "Scatterplot")
})
}
shinyApp(ui, server)
